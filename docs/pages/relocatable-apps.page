<?xml version="1.0"?>
<page xmlns="http://projectmallard.org/1.0/" type="topic" id="relocatable-apps">
<info>
    <link type="topic" xref="app-development"/>

    <credit type="author">
        <name>Matthias Klumpp</name>
        <email>matthias@tenstral.net</email>
        <years>2012</years>
    </credit>
    <credit>
        <name>The Autopackage Team</name>
    </credit>

    <desc>Guide to make your application relocatable</desc>
</info>

<title>Guide to making relocatable applications</title>

<section id="problem">
<title>The problem</title>

<p>Listaller supports relocation. This means that a package can be
installed to any location, like how Win32 installers let you choose a
directory.
However, most applications are not relocatable. The paths where in they
search for data files are usually hardd at compile time.</p>
<p>On Win32, applications and libraries are easily relocatable because
applications and DLLs can use <code>GetModuleFilename()</code> to obtain
their full path.</p>

<p>On Linux however, no easy mechanisms exist. There is no function
equivalent to <code>GetModuleFilename()</code>.
For executables, you can still find your full location by resolving the symlink <file>/proc/self/exe</file>,
but that won't work for libraries.</p>

</section>

<section id="solution">
<title>The solution</title>

<p>This is why we have developed <app>BinReloc</app>.
BinReloc provides an easy-to-use API that uses dynamic linker and kernel
 magic to find out the full path of your application or library.</p>

<list>
 <title>Highlights</title>
 <item><p>It can be statically included in your project.</p></item>
 <item><p>It's small, only about 20 KB of C source code (I suspect it's only
    about 10 KB if you remove all the inline documentation comments).</p></item>
 <item><p>It has absolutely no dependancies other than libc.</p></item>
 <item><p>It's <em>public domain</em>, which means you can do anything you want with the code, including relicensing it under a different license.</p></item>
 <item><p>Portability to other operating systems will not be affected: BinReloc will fallback to hardcoded paths if it's running
    on an operating system which has no executable relocation features.
    You can also completely disable BinReloc with one simple macro, making your program behave exactly like
    when you were using hardcoded paths.</p></item>
 <item><p>There are two versions of BinReloc: a plain C version, and glib version which even has a glib-style API.</p></item>
</list>

<note style="tip">
 <title>Tip for KDE developers</title>
  <p>As of April 21 2004, BinReloc-like functionality has been added to the KDE-libs, in the
  <code>KStandardDirs</code> class. If your <em>application</em> uses <code>KStandardDirs</code>
  to lookup data files, your application will be automatically relocatable, so using BinReloc is not necessary.
  Libraries however will not benefit from this, and must use BinReloc directly.</p>
</note>

</section>

<section id="helloworld">
<title>Hello World!</title>

<p>Let's begin with a BinReloc "Hello World" tutorial. We will use the <em>plain C</em> version of BinReloc.
The glib version's API is only slightly different from the plain C API, so don't worry about the API differences.
In this tutorial, our imaginary developer, Joe, will show you everything he does when writing the <app>Hello World</app> program.</p>

<steps>
 <item><p>Generate BinReloc source files</p>
    <p>Joe <link href="http://listaller.tenstral.net">downloads the BinReloc SDK</link> from the <em>Listaller Tools</em> section of the download page.
        He extracts the archive in his home folder. A folder called <file>binreloc-2.0</file> appears.</p>
    <listing><code><![CDATA[[joe@localhost /home/joe]$ tar xzf binreloc-2.0.tar.gz
[joe@localhost /home/joe]$ cd binreloc-2.0</div>]]></code>
    </listing>
    <p>Joe's Hello World program doesn't use glib, so he wants the plain C version of BinReloc.
    Joe runs the following commands to generate the BinReloc source files:</p>
    <listing><code><![CDATA[[joe@localhost /home/joe/binreloc-2.0]$ ./generate.pl normal
Source code written to 'binreloc.c'
Header written to 'binreloc.h'
[joe@localhost /home/joe/binreloc-2.0]$ mkdir ~/helloworld
[joe@localhost /home/joe/binreloc-2.0]$ mv binreloc.c binreloc.h ~/helloworld/</div>]]></code>
    </listing>
 </item>
 <item><p>Write the program</p>
    <p>Now that Joe has generated the BinReloc source files, he continues with writing a Hello World program:</p>
    <listing><code mime="text/x-c++src"><![CDATA[#include <stdio.h>
#include "binreloc.h"
#ifndef NULL
    #define NULL ((void *) 0)
#endif

int main () {
    BrInitError error;

    if (br_init (&error) == 0 &amp;&amp; error != BR_INIT_ERROR_DISABLED) {
        printf ("Warning: BinReloc failed to initialize (error code %d)\n", error);
        printf ("Will fallback to hardcoded default path.\n");
    }

    printf ("The full path of this application is: %s\n", br_find_exe ("default fallback path"));
    return 0;
}]]></code>
</listing>
 <p>He saves this file as <file>/home/joe/helloworld/hello.c</file>.</p>
</item>

<item><p>Compile &amp; run</p>
    <p>Now it is time to compile &amp; run the program:</p>
    <listing><code mime="text/x-c++src"><![CDATA[[joe@localhost /home/joe/helloworld]$ gcc -DENABLE_BINRELOC hello.c binreloc.c -o hello
[joe@localhost /home/joe/helloworld]$ ./hello
The full path of this application is: /home/joe/helloworld/hello]]></code>
</listing>

<p>Yes, it's this easy!</p>

<note style="tip">
 <title>How to disable BinReloc</title>
    <p>The <code>-DENABLE_BINRELOC</code> argument enables BinReloc support. BinReloc is only enabled if this macro is defined.
        Let's take a look at what happens if the macro is not defined:</p>
<listing><code><![CDATA[[joe@localhost /home/joe/helloworld]$ gcc hello.c binreloc.c -o hello
[joe@localhost /home/joe/helloworld]$ ./hello
The full path of this application is: default fallback path]]></code>
</listing>

</note>
</item>

</steps>

</section>

<section id="init">
<title>Initialization</title>

<p>BinReloc <em>must</em> be initialize by calling one of the BinReloc initialization functions:</p>

<p>If you're using BinReloc in an application, then call <code>br_init()</code>. The definition is:</p>
    <listing><code><![CDATA[int br_init (BrInitError *error);]]></code>
</listing>
    <p>This function returns 1 on success, and 0 if BinReloc failed to initialize.
    If BinReloc failed to initialize, then the error code will be stored in <code>error</code>.
    The following error codes are available:</p>
<listing><code><![CDATA[typedef enum {
        /* Cannot allocate memory. */
        BR_INIT_ERROR_NOMEM,
        /* Unable to open /proc/self/maps; see errno for details. */
        BR_INIT_ERROR_OPEN_MAPS,
        /* Unable to read from /proc/self/maps; see errno for details. */
        BR_INIT_ERROR_READ_MAPS,
        /* The file format of /proc/self/maps is invalid; kernel bug? */
        BR_INIT_ERROR_INVALID_MAPS,
        /* BinReloc is disabled. */
        BR_INIT_ERROR_DISABLED
} BrInitError;
]]></code>
</listing>
<p>If you're using BinReloc in a library, then call <code>br_init_lib()</code>. The definition is:</p>
<code>int br_init_lib (BrInitError *error);</code>
<p>This function returns 1 on success, and 0 if BinReloc failed to initialize.</p>
<p>If you don't initialize BinReloc, or if initialization failed, then all BinReloc functions will return
the fallback paths, so even if initialization failed, it's not fatal. Initialization will fail
if BinReloc is disabled (because <code>ENABLE_BINRELOC</code> is not defined), or because the application
is running on a platform which doesn't support relocating executables (non-Linux platforms).</p>

</section>


<section id="basic">
<title>Basic usage</title>

<p>There are more functions besides <code>br_find_exe()</code>. Here is a list of all relocation functions:</p>
<table shade="rows">
 <tbody>
  <tr>
    <td><p>Function</p></td> <td><p>Returns</p></td>
  </tr>
 </tbody>
 <tbody>
  <tr>
    <td><p><code>br_find_exe()</code></p></td> <td><p>The full path of your application or library.</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_exe_dir()</code></p></td> <td><p>The folder in which your application or library is located.</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_prefix()</code></p></td>
<td>
<p>
The prefix in which your application or library is located.
        This function assumes that your binary is located
        inside an FHS-compatible directory structure (<file>$prefix/bin/</file> or <file>$prefix/lib/</file>). Examples:</p>
        <list>
        <item><p>Your binary is <file>/usr/bin/foo</file>. It will return <file>/usr</file>.</p></item>
        <item><p>Your library is <file>/usr/local/lib/libfoo.so</file>. It will return <file>/usr/local</file>.</p></item>
        <item><p>Your binary is <file>/Applications/CoolApp2040XP/CoolApp</file>. It will return <file>/Applications"</file>.</p></item>
        </list>
        <p>So basically, it returns <em>dirname(executable_filename) + "/.."</em></p>
</td>
  </tr>
  <tr>
    <td><p><code>br_find_bin_dir()</code></p></td> <td><p>PREFIX + "/bin"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_sbin_dir()</code></p></td> <td><p>PREFIX + "/sbin"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_data_dir()</code></p></td> <td><p>PREFIX + "/share"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_locale_dir()</code></p></td> <td><p>PREFIX + "/locale"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_lib_dir()</code></p></td> <td><p>PREFIX + "/lib"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_libexec_dir()</code></p></td> <td><p>PREFIX + "/libexec"</p></td>
  </tr>
  <tr>
    <td><p><code>br_find_etc_dir()</code></p></td> <td><p>PREFIX + "/etc"</p></td>
  </tr>
 </tbody>
</table>

<p>
All functions in the above table are declared like this:
<code>char *br_find_something (const char *default_path);</code></p>
<p><code>default_path</code> is used as fallback: if the BinReloc isn't initialized, or failed to initialize,
then a copy of default_path will be returned. Or if the default_path is NULL, NULL will be returned.</p>

<note style="warning">
<p>
Note that the return values of all of the above functions must be freed
when no longer necessary, except if the return value is NULL.
</p>
</note>

<p>
<em>All</em> BinReloc functions have inline documentation! So just take a look at <file>binreloc.c</file> if you need more info about a certain function.
</p>

</section>


<section id="glib">
<title>GLib-style API</title>

<p>There's also a BinReloc version with a glib-style API. Generating this version is just like generating the normal version:</p>
<listing><code><![CDATA[[joe@localhost /home/joe/binreloc-2.0]$ ./generate.pl glib
Source code written to 'binreloc.c'
Header written to 'binreloc.h']]></code></listing>

<p>
The API is almost identical to the plain C version, except that it uses glib-style names and glib data types, such as GError.
See <link href="http://listaller.nlinux.org">the full API reference</link>.
</p>
</section>


<section id="utility">
<title>Useful utility functions</title>

<p>The plain C version of BinReloc provides some utility functions for modifying strings and paths,
because many applications will need such functionality. The GLib version doesn't contain these utility functions
because GLib already has its own utility functions. Note that these utility functions are fully portable, and can be used
even when BinReloc is not enabled/initialized.</p>
<code mime="text/x-c++src">char *br_strcat (const char *str1, const char *str2);</code>
<list>
<item><p>str1: A string.</p></item>
<item><p>str2: Another string.</p></item>
<item><p>Returns: A newly-allocated string. This string should be freed when no longer needed.</p></item>
</list>
<p>Concatenate str1 and str2 to a newly allocated string.</p>
<p>Example:</p>
<listing><code mime="text/x-c++src"><![CDATA[char *datafile;

datafile = br_strcat ("/usr", "/foo/mydata.txt");
load_data_file (datafile);
free (datafile);</pre>
]]></code></listing>

</section>

<section id="autoconf">
<title>Autoconf/Automake build system integration</title>

<p>Most Autoconf/Automake projects use macros that define a hardcoded path.
Let's take a look at this piece of code as example.</p>

<p>In <file>Makefile.am</file>:</p>
<code><![CDATA[INCLUDES = $(LIBGLADE_CFLAGS) \
           -DDATADIR=\"$(datadir)\"

bin_PROGRAMS = foo
foo_SOURCES = main.c]]></code>

<p>In <file>main.c</file>:</p>
<code mime="text/x-c++src">xml = glade_xml_new (DATADIR "/foobar/glade/main.glade", NULL, NULL);</code>

<p>How to use BinReloc:</p>
<steps>
<item><p>Use the special BinReloc Autoconf Macro (<file>binreloc.m4</file>). This file can be found in
    the <link href="http://listaller.nlinux.org">BinReloc SDK</link>.</p><p>
    Append the contents of <file>binreloc.m4</file> to <file>acinclude.m4</file> (which is in the same
    folder as <file>configure.in</file>). Create <file>acinclude.m4</file> if it doesn't exist.</p>
    <p>
    In <file>configure.in</file>, put the command <code>AM_BINRELOC</code> somewhere.
    </p>
    <p>
    The AM_BINRELOC macro checks whether BinReloc should be enabled (whether the system supports the feature,
    whether the user explicitly disabled it, etc). The variable <code>$br_cv_binreloc</code>
    will be set to 'yes' if BinReloc is enabled, or 'no' otherwise.</p>
</item>
<item>
    <p>Copy <file>binreloc.c</file> and <file>binreloc.h</file> to your source code directory.</p>
</item>
<item>
    <p>Add <code>BINRELOC_CFLAGS</code> and <file>binreloc.c/binreloc.h</file> to <file>Makefile.am</file>:</p>
    <code><![CDATA[AM_CPPFLAGS = $(BINRELOC_CFLAGS)
...
foo_SOURCES = main.c <span class="highlight">\
              binreloc.h \
              binreloc.c]]></code>
</item>
<item>
    <p>At the beginning of <file>main.c</file>, add:</p>
    <code mime="text/x-c++src">#include "binreloc.h"</code>
    <p>
    Somewhere in <file>main.c</file>:</p>
    <code mime="text/x-c++src"><![CDATA[gchar *dir, *file;

gbr_init (NULL);
dir = br_find_data_dir (DEFAULT_DATA_DIR);
file = g_strdup_printf ("%s/foobar/glade/main.glade", dir);
g_free (dir);

xml = glade_xml_new (file, NULL, NULL);
g_free (file);]]></code>
</item>
</steps>

<p>
And that was it! Your configure script will now have a <em>--enable-binreloc=[yes/no/auto]</em> option.
The default value for this option is <em>--enable-binreloc=auto</em>, which will automatically check whether BinReloc support is
desired. It does so by checking for the following things:
</p>
<list>
 <item><p>Whether <file>/proc/self/maps</file> is available.</p></item>
 <item><p>Whether the user told configure to use a different location for a specific directory, such as by passing <em>--bindir=/foo/bin</em>.</p></item>
</list>
<p>Users can always disable BinReloc manually by passing <em>--disable-binreloc</em> to the <em>configure</em> script.</p>

</section>

<section id="kde">
<title>KDE integration</title>

<note style="tip">
 <title>Note to KDE developers</title>
  <p>As of April 21 2004, BinReloc-like functionality has been added to the KDE-libs, in the
  <code>KStandardDirs</code> class. If your <em>application</em> uses <code>KStandardDirs</code>
  to lookup data files, your application will be automatically relocatable, so using BinReloc is not necessary.
  Libraries however will not benefit from this, and must use BinReloc directly.</p>
</note>

<p>In your program's initialization function, add the following code:</p>
<code mime="text/x-c++src"><![CDATA[KGlobal::dirs()->addPrefix(br_find_prefix(DEFAULT_PREFIX));]]></code>
<p>Make sure you use <code>KGlobal::dirs()</code> to lookup data files througout your entire program.
If you create new instances of <code>KStandardDirs</code>, you need the re-add the prefix.</p>

<p>
If you want to use <code>KIconLoader</code> to load icons from whever your program is installed, add this:
</p>
<code mime="text/x-c++src"><![CDATA[KGlobal::iconLoader()->addAppDir(br_find_data_dir(DEFAULT_DATA_DIR));]]></code>
</section>

<section id="api">
<title>Full API reference</title>

<p>... will be available very soon!</p>
</section>

<section id="more">
<title>More examples</title>
<p>The <file>contrib/binreloc/tests</file> folder in the Listaller source tarball contains more examples about how to use BinReloc.</p>
</section>

</page>
